/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 2.0.0-dev
 * apibuilder 0.14.59 app.apibuilder.io/hbc/svc-sundial/2.0.0-dev/play_2_x_json
 */
package com.hbc.svc.sundial.v2.models {

  /**
   * The EC2 market of the EC2 instances
   */
  sealed trait AwsMarket extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Whether or not to create a new EMR cluster or re-use a pre-existing one
   */
  sealed trait EmrCluster extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * The EMR role to use on the EC2 instances
   */
  sealed trait EmrJobFlowRole extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * The EMR service role to use
   */
  sealed trait EmrServiceRole extends _root_.scala.Product with _root_.scala.Serializable

  sealed trait Notification extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * A specification for when a process should be run
   */
  sealed trait ProcessSchedule extends _root_.scala.Product with _root_.scala.Serializable

  sealed trait TaskExecutable extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * @param image Name of docker image including registry URL if needed
   * @param tag Tag on docker image
   * @param command Command to pass to Docker container
   * @param jobRoleArn ARN of an IAM role, see
   *        http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html
   * @param environmentVariables environment variables to be passed to container
   * @param jobQueue Override default job queue, eg: for priority queue or GPU instances queue
   */
  final case class BatchImageCommand(
    image: String,
    tag: String = "latest",
    command: Seq[String],
    memory: Int,
    vCpus: Int,
    jobRoleArn: _root_.scala.Option[String] = None,
    environmentVariables: Seq[com.hbc.svc.sundial.v2.models.EnvironmentVariable] = Nil,
    jobQueue: _root_.scala.Option[String] = None
  ) extends TaskExecutable

  /**
   * @param bufferSeconds The minimum amount of time (in seconds) that must pass between executions of the
   *        process
   */
  final case class ContinuousSchedule(
    bufferSeconds: _root_.scala.Option[Int] = None
  ) extends ProcessSchedule

  /**
   * See http://quartz-scheduler.org/api/2.2.0/org/quartz/CronExpression.html
   */
  final case class CronSchedule(
    dayOfWeek: String,
    month: String,
    dayOfMonth: String,
    hours: String,
    minutes: String
  ) extends ProcessSchedule

  /**
   * Custom, preconfigured, EMR EC2 instance role
   */
  final case class CustomEmrJobFlowRole(
    roleName: String
  ) extends EmrJobFlowRole

  /**
   * Custom, preconfigured, EMR Service role
   */
  final case class CustomEmrServiceRole(
    roleName: String
  ) extends EmrServiceRole

  /**
   * An email to send notifications to
   */
  final case class Email(
    name: String,
    email: String,
    notifyWhen: com.hbc.svc.sundial.v2.models.NotificationOptions = com.hbc.svc.sundial.v2.models.NotificationOptions.OnStateChangeAndFailures
  ) extends Notification

  /**
   * @param emrCluster The EMR cluster on which to launch the job (aka step)
   * @param jobName NAme to be assigned to the Job
   * @param region the AWS Region
   * @param `class` The spark job's `Main.class` to run
   * @param s3JarPath the s3 path to the jar of the job to be run
   * @param sparkConf options that will be sent to spark as --conf key=value, e.g. `--conf
   *        spark.driver.extraJavaOptions=-Denvironment=integration`
   * @param sparkPackages External maven dependencies to include with Spark job
   * @param args command line arguments to be passe to the job's main class
   * @param s3LogDetails AWS EMR periodically (currently every 5 minutes) zips up all the logs and upload
   *        them into S3. This does not work well with sundial's _live logs_. Make use of S3
   *        Logs to visualise in real time job's log on sundial's live logs panel
   * @param loadData will trigger a s3 dist cp job for every entry in this array, can be used to load
   *        data from s3 into HDFS. **requires Hadoop** as application on the cluster
   * @param saveResults will trigger a s3 dist cp job for every entry in this array, can be used to save
   *        data from HDFS to s3. **requires Hadoop** as application on the cluster
   */
  final case class EmrCommand(
    emrCluster: com.hbc.svc.sundial.v2.models.EmrCluster,
    jobName: String,
    region: String = "us-east-1",
    `class`: String,
    s3JarPath: String,
    sparkConf: Seq[String],
    sparkPackages: Seq[com.hbc.svc.sundial.v2.models.MavenPackage] = Nil,
    args: Seq[String],
    s3LogDetails: _root_.scala.Option[com.hbc.svc.sundial.v2.models.S3LogDetails] = None,
    loadData: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.S3Cp]] = None,
    saveResults: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.S3Cp]] = None
  ) extends TaskExecutable

  /**
   * See https://docs.aws.amazon.com/emr/latest/ReleaseGuide/emr-configure-apps.html
   */
  final case class EmrConfiguration(
    classification: _root_.scala.Option[String] = None,
    configurations: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.EmrConfiguration]] = None,
    properties: _root_.scala.Option[Map[String, String]] = None
  )

  /**
   * Additional configuration for Master/Core/Task EMR instance Groups.
   * 
   * @param ebsVolumeSize optional EBS volume in GB to attach to the emr instance, for simplicity only one
   *        volume for the given size and type gp2 will be created.
   */
  final case class EmrInstanceGroupDetails(
    emrInstanceType: String,
    instanceCount: Int,
    awsMarket: com.hbc.svc.sundial.v2.models.AwsMarket,
    ebsVolumeSize: _root_.scala.Option[Int] = None
  )

  final case class EnvironmentVariable(
    variableName: String,
    value: String
  )

  /**
   * Existing EMR cluster configuration object
   * 
   * @param clusterId The EMR cluster id
   */
  final case class ExistingEmrCluster(
    clusterId: String
  ) extends EmrCluster

  final case class Healthcheck(
    status: String
  )

  /**
   * @param logEntryId Uniquely identifies the log message to prevent duplication
   */
  final case class LogEntry(
    logEntryId: _root_.java.util.UUID,
    when: _root_.org.joda.time.DateTime,
    source: String,
    message: String
  )

  final case class MavenPackage(
    groupId: String,
    artifactId: String,
    version: String
  )

  /**
   * @param metadataEntryId Uniquely identifies the metadata entry to prevent duplication
   */
  final case class MetadataEntry(
    metadataEntryId: _root_.java.util.UUID,
    when: _root_.org.joda.time.DateTime,
    key: String,
    value: String
  )

  /**
   * New EMR cluster configuration object
   * 
   * @param ec2Subnet To be set in case the EMR cannot be launched in the `default VPC`
   * @param emrServiceRole role to be assigned to the service, the default one should cover most of the
   *        cases
   * @param emrJobFlowRole role to be assigned to the ec2 instances composing the EMR cluster. The default
   *        one should cover most of the cases
   * @param visibleToAllUsers whether or not to show the new cluster in the list of clusters. For more details
   *        see [emr
   *        docs](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-emr-cluster.html#cfn-emr-cluster-visibletoallusers)
   * @param configurations Extra configuration to be applied to cluster, see
   *        https://docs.aws.amazon.com/emr/latest/APIReference/API_Configuration.html
   * @param securityConfiguration Allow you to specify a security configuration for the cluster
   */
  final case class NewEmrCluster(
    name: String,
    releaseLabel: com.hbc.svc.sundial.v2.models.EmrReleaseLabel = com.hbc.svc.sundial.v2.models.EmrReleaseLabel.Emr5100,
    applications: Seq[com.hbc.svc.sundial.v2.models.EmrApplication],
    s3LogUri: String,
    masterInstance: com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails,
    coreInstance: _root_.scala.Option[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails] = None,
    taskInstance: _root_.scala.Option[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails] = None,
    ec2Subnet: _root_.scala.Option[String] = None,
    emrServiceRole: com.hbc.svc.sundial.v2.models.EmrServiceRole,
    emrJobFlowRole: com.hbc.svc.sundial.v2.models.EmrJobFlowRole,
    visibleToAllUsers: Boolean = false,
    configurations: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.EmrConfiguration]] = None,
    securityConfiguration: _root_.scala.Option[String] = None
  ) extends EmrCluster

  /**
   * Pager Duty integration
   */
  final case class Pagerduty(
    serviceKey: String,
    numConsecutiveFailures: Int = 1,
    apiUrl: String = "https://events.pagerduty.com"
  ) extends Notification

  final case class Process(
    processId: _root_.java.util.UUID,
    processDefinitionName: String,
    startTime: _root_.org.joda.time.DateTime,
    status: com.hbc.svc.sundial.v2.models.ProcessStatus,
    task: Seq[com.hbc.svc.sundial.v2.models.Task]
  )

  /**
   * A grouping of related tasks that are run as a single unit on the same schedule
   * 
   * @param paused If true, ignore schedule and only start process if triggered manually
   * @param schedule The schedule that the process runs on; if not specified, the process will only
   *        run when triggered manually
   */
  final case class ProcessDefinition(
    processDefinitionName: String,
    paused: _root_.scala.Option[Boolean] = None,
    processDescription: _root_.scala.Option[String] = None,
    schedule: _root_.scala.Option[com.hbc.svc.sundial.v2.models.ProcessSchedule] = None,
    taskDefinitions: Seq[com.hbc.svc.sundial.v2.models.TaskDefinition],
    overlapAction: com.hbc.svc.sundial.v2.models.ProcessOverlapAction = com.hbc.svc.sundial.v2.models.ProcessOverlapAction.Wait,
    notifications: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.Notification]] = None
  )

  /**
   * Wrapper of the S3DistCp spark job for more info visit the aws
   * [s3-dist-cp](https://docs.aws.amazon.com/emr/latest/ReleaseGuide/UsingEMR_s3distcp.html)
   * page
   * 
   * @param source Source folder or file to copy. It can be either a s3 or HDFS location
   * @param destination Source folder or file to copy. It can be either a s3 or HDFS location
   */
  final case class S3Cp(
    source: String,
    destination: String
  )

  final case class S3LogDetails(
    logGroupName: String,
    logStreamName: String
  )

  final case class ShellScriptCommand(
    script: String,
    environmentVariables: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.EnvironmentVariable]] = None
  ) extends TaskExecutable

  /**
   * the maximum spot bid price
   */
  final case class Spot(
    bidPrice: BigDecimal
  ) extends AwsMarket

  /**
   * @param executionState Internal bookkeeping metadata used for task scheduling (e.g. ECS task ID and
   *        cluster name)
   */
  final case class Task(
    taskId: _root_.java.util.UUID,
    processId: _root_.java.util.UUID,
    processDefinitionName: String,
    taskDefinitionName: String,
    startTime: _root_.org.joda.time.DateTime,
    endTime: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
    previousAttemptCount: Int,
    logEntries: Seq[com.hbc.svc.sundial.v2.models.LogEntry],
    metadataEntries: Seq[com.hbc.svc.sundial.v2.models.MetadataEntry],
    executionState: _root_.scala.Option[Seq[com.hbc.svc.sundial.v2.models.MetadataEntry]] = None,
    status: com.hbc.svc.sundial.v2.models.TaskStatus
  )

  /**
   * An individual task that runs as part of a process
   * 
   * @param taskDefinitionName The canonical name for this task used by other tasks to identify this task
   * @param dependencies The tasks that must have completed prior to this one beginning
   * @param maxRuntimeSeconds The execution time (for a single attempt) after which the system will kill the
   *        task
   * @param requireExplicitSuccess If true, the task must explicitly update its status with Sundial in order to
   *        succeed.
   */
  final case class TaskDefinition(
    taskDefinitionName: String,
    dependencies: Seq[com.hbc.svc.sundial.v2.models.TaskDependency],
    executable: com.hbc.svc.sundial.v2.models.TaskExecutable,
    maxAttempts: Int,
    maxRuntimeSeconds: _root_.scala.Option[Int] = None,
    backoffBaseSeconds: Int,
    backoffExponent: Double = 1.0,
    requireExplicitSuccess: Boolean = false
  )

  final case class TaskDependency(
    taskDefinitionName: String,
    successRequired: Boolean = true
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union AwsMarket, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class AwsMarketUndefinedType(
    description: String
  ) extends AwsMarket

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union EmrCluster, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class EmrClusterUndefinedType(
    description: String
  ) extends EmrCluster

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union EmrJobFlowRole, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class EmrJobFlowRoleUndefinedType(
    description: String
  ) extends EmrJobFlowRole

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union EmrServiceRole, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class EmrServiceRoleUndefinedType(
    description: String
  ) extends EmrServiceRole

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Notification, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class NotificationUndefinedType(
    description: String
  ) extends Notification

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union ProcessSchedule, it will need to be handled in the client code.
   * This implementation will deserialize these future types as an instance of this
   * class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ProcessScheduleUndefinedType(
    description: String
  ) extends ProcessSchedule

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union TaskExecutable, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class TaskExecutableUndefinedType(
    description: String
  ) extends TaskExecutable

  /**
   * The default EMR EC2 Instance role
   */
  sealed trait DefaultEmrJobFlowRole extends EmrJobFlowRole

  object DefaultEmrJobFlowRole {

    case object DefaultEmrJobFlowRole extends DefaultEmrJobFlowRole { override def toString = "EMR_EC2_DefaultRole" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DefaultEmrJobFlowRole

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DefaultEmrJobFlowRole] = scala.List(DefaultEmrJobFlowRole)

    private[this]
    val byName: Map[String, DefaultEmrJobFlowRole] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DefaultEmrJobFlowRole = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DefaultEmrJobFlowRole] = byName.get(value.toLowerCase)

  }

  /**
   * The default EMR Service role
   */
  sealed trait DefaultEmrServiceRole extends EmrServiceRole

  object DefaultEmrServiceRole {

    case object DefaultEmrServiceRole extends DefaultEmrServiceRole { override def toString = "EMR_DefaultRole" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends DefaultEmrServiceRole

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[DefaultEmrServiceRole] = scala.List(DefaultEmrServiceRole)

    private[this]
    val byName: Map[String, DefaultEmrServiceRole] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): DefaultEmrServiceRole = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[DefaultEmrServiceRole] = byName.get(value.toLowerCase)

  }

  /**
   * List of applications to install in the EMR cluster
   */
  sealed trait EmrApplication extends _root_.scala.Product with _root_.scala.Serializable

  object EmrApplication {

    case object Hadoop extends EmrApplication { override def toString = "Hadoop" }
    case object Hive extends EmrApplication { override def toString = "Hive" }
    case object Mahout extends EmrApplication { override def toString = "Mahout" }
    case object Pig extends EmrApplication { override def toString = "Pig" }
    case object Spark extends EmrApplication { override def toString = "Spark" }
    case object Ganglia extends EmrApplication { override def toString = "Ganglia" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends EmrApplication

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[EmrApplication] = scala.List(Hadoop, Hive, Mahout, Pig, Spark, Ganglia)

    private[this]
    val byName: Map[String, EmrApplication] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): EmrApplication = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[EmrApplication] = byName.get(value.toLowerCase)

  }

  /**
   * Version (aka label in AWS-EMR) of the EMR stack to create.
   */
  sealed trait EmrReleaseLabel extends _root_.scala.Product with _root_.scala.Serializable

  object EmrReleaseLabel {

    case object Emr5200 extends EmrReleaseLabel { override def toString = "emr-5.20.0" }
    case object Emr5190 extends EmrReleaseLabel { override def toString = "emr-5.19.0" }
    case object Emr5180 extends EmrReleaseLabel { override def toString = "emr-5.18.0" }
    case object Emr5170 extends EmrReleaseLabel { override def toString = "emr-5.17.0" }
    case object Emr5160 extends EmrReleaseLabel { override def toString = "emr-5.16.0" }
    case object Emr5150 extends EmrReleaseLabel { override def toString = "emr-5.15.0" }
    case object Emr5140 extends EmrReleaseLabel { override def toString = "emr-5.14.0" }
    case object Emr5130 extends EmrReleaseLabel { override def toString = "emr-5.13.0" }
    case object Emr5121 extends EmrReleaseLabel { override def toString = "emr-5.12.1" }
    case object Emr5120 extends EmrReleaseLabel { override def toString = "emr-5.12.0" }
    case object Emr5111 extends EmrReleaseLabel { override def toString = "emr-5.11.1" }
    case object Emr5110 extends EmrReleaseLabel { override def toString = "emr-5.11.0" }
    case object Emr5100 extends EmrReleaseLabel { override def toString = "emr-5.10.0" }
    case object Emr590 extends EmrReleaseLabel { override def toString = "emr-5.9.0" }
    case object Emr492 extends EmrReleaseLabel { override def toString = "emr-4.9.2" }
    case object Emr491 extends EmrReleaseLabel { override def toString = "emr-4.9.1" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends EmrReleaseLabel

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[EmrReleaseLabel] = scala.List(Emr5200, Emr5190, Emr5180, Emr5170, Emr5160, Emr5150, Emr5140, Emr5130, Emr5121, Emr5120, Emr5111, Emr5110, Emr5100, Emr590, Emr492, Emr491)

    private[this]
    val byName: Map[String, EmrReleaseLabel] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): EmrReleaseLabel = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[EmrReleaseLabel] = byName.get(value.toLowerCase)

  }

  sealed trait NotificationOptions extends _root_.scala.Product with _root_.scala.Serializable

  object NotificationOptions {

    /**
     * Always notify when a process completes
     */
    case object Always extends NotificationOptions { override def toString = "always" }
    /**
     * Notify when a process fails
     */
    case object OnFailure extends NotificationOptions { override def toString = "on_failure" }
    /**
     * Notify when a process goes from succeeding to failing and vica versa
     */
    case object OnStateChange extends NotificationOptions { override def toString = "on_state_change" }
    /**
     * Notify when going from failing to succeeded and on each failure
     */
    case object OnStateChangeAndFailures extends NotificationOptions { override def toString = "on_state_change_and_failures" }
    /**
     * Never notify
     */
    case object Never extends NotificationOptions { override def toString = "never" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends NotificationOptions

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[NotificationOptions] = scala.List(Always, OnFailure, OnStateChange, OnStateChangeAndFailures, Never)

    private[this]
    val byName: Map[String, NotificationOptions] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): NotificationOptions = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[NotificationOptions] = byName.get(value.toLowerCase)

  }

  /**
   * The onDemand type of Market Type
   */
  sealed trait OnDemand extends AwsMarket

  object OnDemand {

    case object OnDemand extends OnDemand { override def toString = "on_demand" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OnDemand

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OnDemand] = scala.List(OnDemand)

    private[this]
    val byName: Map[String, OnDemand] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OnDemand = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OnDemand] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessOverlapAction extends _root_.scala.Product with _root_.scala.Serializable

  object ProcessOverlapAction {

    /**
     * The process should wait until the currently running instance finishes
     */
    case object Wait extends ProcessOverlapAction { override def toString = "wait" }
    /**
     * The currently running process should be killed
     */
    case object Terminate extends ProcessOverlapAction { override def toString = "terminate" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ProcessOverlapAction

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ProcessOverlapAction] = scala.List(Wait, Terminate)

    private[this]
    val byName: Map[String, ProcessOverlapAction] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessOverlapAction = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessOverlapAction] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ProcessStatus {

    /**
     * The process has tasks currently executing
     */
    case object Running extends ProcessStatus { override def toString = "running" }
    /**
     * All of the process's tasks succeeded on its last run
     */
    case object Succeeded extends ProcessStatus { override def toString = "succeeded" }
    /**
     * At least one of the process's tasks failed on its last run
     */
    case object Failed extends ProcessStatus { override def toString = "failed" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ProcessStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ProcessStatus] = scala.List(Running, Succeeded, Failed)

    private[this]
    val byName: Map[String, ProcessStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessStatus] = byName.get(value.toLowerCase)

  }

  sealed trait TaskStatus extends _root_.scala.Product with _root_.scala.Serializable

  object TaskStatus {

    /**
     * The task has been submitted
     */
    case object Submitted extends TaskStatus { override def toString = "submitted" }
    case object Runnable extends TaskStatus { override def toString = "runnable" }
    case object Starting extends TaskStatus { override def toString = "starting" }
    /**
     * The task is waiting on compute resources
     */
    case object Pending extends TaskStatus { override def toString = "pending" }
    /**
     * The task is currently executing or awaiting backoff
     */
    case object Running extends TaskStatus { override def toString = "running" }
    /**
     * The task has irrevocably failed
     */
    case object Failed extends TaskStatus { override def toString = "failed" }
    /**
     * The task has succeeded without serious errors
     */
    case object Succeeded extends TaskStatus { override def toString = "succeeded" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends TaskStatus

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[TaskStatus] = scala.List(Submitted, Runnable, Starting, Pending, Running, Failed, Succeeded)

    private[this]
    val byName: Map[String, TaskStatus] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaskStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaskStatus] = byName.get(value.toLowerCase)

  }

}

package com.hbc.svc.sundial.v2.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import com.hbc.svc.sundial.v2.models.json._

    private[v2] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v2] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v2] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v2] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    private[v2] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateParser
      dateParser.parseLocalDate(str)
    }

    private[v2] implicit val jsonWritesJodaLocalDate = new Writes[org.joda.time.LocalDate] {
      def writes(x: org.joda.time.LocalDate) = {
        import org.joda.time.format.ISODateTimeFormat.date
        val str = date.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsSvcSundialDefaultEmrJobFlowRole = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialDefaultEmrJobFlowRole(obj: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDefaultEmrJobFlowRole(obj: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialDefaultEmrJobFlowRole: play.api.libs.json.Writes[DefaultEmrJobFlowRole] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] {
        def writes(obj: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole) = {
          jsonWritesSvcSundialDefaultEmrJobFlowRole(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialDefaultEmrServiceRole = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialDefaultEmrServiceRole(obj: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectDefaultEmrServiceRole(obj: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialDefaultEmrServiceRole: play.api.libs.json.Writes[DefaultEmrServiceRole] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] {
        def writes(obj: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole) = {
          jsonWritesSvcSundialDefaultEmrServiceRole(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialEmrApplication = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.EmrApplication] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.EmrApplication] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrApplication(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrApplication(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialEmrApplication(obj: com.hbc.svc.sundial.v2.models.EmrApplication) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEmrApplication(obj: com.hbc.svc.sundial.v2.models.EmrApplication) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialEmrApplication: play.api.libs.json.Writes[EmrApplication] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrApplication] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrApplication) = {
          jsonWritesSvcSundialEmrApplication(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialEmrReleaseLabel = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrReleaseLabel(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrReleaseLabel(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialEmrReleaseLabel(obj: com.hbc.svc.sundial.v2.models.EmrReleaseLabel) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEmrReleaseLabel(obj: com.hbc.svc.sundial.v2.models.EmrReleaseLabel) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialEmrReleaseLabel: play.api.libs.json.Writes[EmrReleaseLabel] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrReleaseLabel) = {
          jsonWritesSvcSundialEmrReleaseLabel(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialNotificationOptions = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.NotificationOptions] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.NotificationOptions] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.NotificationOptions(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.NotificationOptions(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialNotificationOptions(obj: com.hbc.svc.sundial.v2.models.NotificationOptions) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectNotificationOptions(obj: com.hbc.svc.sundial.v2.models.NotificationOptions) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialNotificationOptions: play.api.libs.json.Writes[NotificationOptions] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.NotificationOptions] {
        def writes(obj: com.hbc.svc.sundial.v2.models.NotificationOptions) = {
          jsonWritesSvcSundialNotificationOptions(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialOnDemand = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.OnDemand] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.OnDemand] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.OnDemand(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.OnDemand(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialOnDemand(obj: com.hbc.svc.sundial.v2.models.OnDemand) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOnDemand(obj: com.hbc.svc.sundial.v2.models.OnDemand) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialOnDemand: play.api.libs.json.Writes[OnDemand] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.OnDemand] {
        def writes(obj: com.hbc.svc.sundial.v2.models.OnDemand) = {
          jsonWritesSvcSundialOnDemand(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessOverlapAction = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.ProcessOverlapAction(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.ProcessOverlapAction(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessOverlapAction(obj: com.hbc.svc.sundial.v2.models.ProcessOverlapAction) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessOverlapAction(obj: com.hbc.svc.sundial.v2.models.ProcessOverlapAction) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessOverlapAction: play.api.libs.json.Writes[ProcessOverlapAction] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] {
        def writes(obj: com.hbc.svc.sundial.v2.models.ProcessOverlapAction) = {
          jsonWritesSvcSundialProcessOverlapAction(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessStatus = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.ProcessStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.ProcessStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.ProcessStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.ProcessStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessStatus(obj: com.hbc.svc.sundial.v2.models.ProcessStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessStatus(obj: com.hbc.svc.sundial.v2.models.ProcessStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessStatus: play.api.libs.json.Writes[ProcessStatus] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.ProcessStatus] {
        def writes(obj: com.hbc.svc.sundial.v2.models.ProcessStatus) = {
          jsonWritesSvcSundialProcessStatus(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialTaskStatus = new play.api.libs.json.Reads[com.hbc.svc.sundial.v2.models.TaskStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.hbc.svc.sundial.v2.models.TaskStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.TaskStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.TaskStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialTaskStatus(obj: com.hbc.svc.sundial.v2.models.TaskStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaskStatus(obj: com.hbc.svc.sundial.v2.models.TaskStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialTaskStatus: play.api.libs.json.Writes[TaskStatus] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.TaskStatus] {
        def writes(obj: com.hbc.svc.sundial.v2.models.TaskStatus) = {
          jsonWritesSvcSundialTaskStatus(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialBatchImageCommand: play.api.libs.json.Reads[BatchImageCommand] = {
      for {
        image <- (__ \ "image").read[String]
        tag <- (__ \ "tag").read[String]
        command <- (__ \ "command").read[Seq[String]]
        memory <- (__ \ "memory").read[Int]
        vCpus <- (__ \ "vCpus").read[Int]
        jobRoleArn <- (__ \ "job_role_arn").readNullable[String]
        environmentVariables <- (__ \ "environment_variables").read[Seq[com.hbc.svc.sundial.v2.models.EnvironmentVariable]]
        jobQueue <- (__ \ "job_queue").readNullable[String]
      } yield BatchImageCommand(image, tag, command, memory, vCpus, jobRoleArn, environmentVariables, jobQueue)
    }

    def jsObjectBatchImageCommand(obj: com.hbc.svc.sundial.v2.models.BatchImageCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "image" -> play.api.libs.json.JsString(obj.image),
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "command" -> play.api.libs.json.Json.toJson(obj.command),
        "memory" -> play.api.libs.json.JsNumber(obj.memory),
        "vCpus" -> play.api.libs.json.JsNumber(obj.vCpus),
        "environment_variables" -> play.api.libs.json.Json.toJson(obj.environmentVariables)
      ) ++ (obj.jobRoleArn match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("job_role_arn" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.jobQueue match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("job_queue" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsSvcSundialContinuousSchedule: play.api.libs.json.Reads[ContinuousSchedule] = {
      (__ \ "buffer_seconds").readNullable[Int].map { x => new ContinuousSchedule(bufferSeconds = x) }
    }

    def jsObjectContinuousSchedule(obj: com.hbc.svc.sundial.v2.models.ContinuousSchedule): play.api.libs.json.JsObject = {
      (obj.bufferSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("buffer_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonReadsSvcSundialCronSchedule: play.api.libs.json.Reads[CronSchedule] = {
      for {
        dayOfWeek <- (__ \ "day_of_week").read[String]
        month <- (__ \ "month").read[String]
        dayOfMonth <- (__ \ "day_of_month").read[String]
        hours <- (__ \ "hours").read[String]
        minutes <- (__ \ "minutes").read[String]
      } yield CronSchedule(dayOfWeek, month, dayOfMonth, hours, minutes)
    }

    def jsObjectCronSchedule(obj: com.hbc.svc.sundial.v2.models.CronSchedule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "day_of_week" -> play.api.libs.json.JsString(obj.dayOfWeek),
        "month" -> play.api.libs.json.JsString(obj.month),
        "day_of_month" -> play.api.libs.json.JsString(obj.dayOfMonth),
        "hours" -> play.api.libs.json.JsString(obj.hours),
        "minutes" -> play.api.libs.json.JsString(obj.minutes)
      )
    }

    implicit def jsonReadsSvcSundialCustomEmrJobFlowRole: play.api.libs.json.Reads[CustomEmrJobFlowRole] = {
      (__ \ "role_name").read[String].map { x => new CustomEmrJobFlowRole(roleName = x) }
    }

    def jsObjectCustomEmrJobFlowRole(obj: com.hbc.svc.sundial.v2.models.CustomEmrJobFlowRole): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "role_name" -> play.api.libs.json.JsString(obj.roleName)
      )
    }

    implicit def jsonReadsSvcSundialCustomEmrServiceRole: play.api.libs.json.Reads[CustomEmrServiceRole] = {
      (__ \ "role_name").read[String].map { x => new CustomEmrServiceRole(roleName = x) }
    }

    def jsObjectCustomEmrServiceRole(obj: com.hbc.svc.sundial.v2.models.CustomEmrServiceRole): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "role_name" -> play.api.libs.json.JsString(obj.roleName)
      )
    }

    implicit def jsonReadsSvcSundialEmail: play.api.libs.json.Reads[Email] = {
      for {
        name <- (__ \ "name").read[String]
        email <- (__ \ "email").read[String]
        notifyWhen <- (__ \ "notify_when").read[com.hbc.svc.sundial.v2.models.NotificationOptions]
      } yield Email(name, email, notifyWhen)
    }

    def jsObjectEmail(obj: com.hbc.svc.sundial.v2.models.Email): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "email" -> play.api.libs.json.JsString(obj.email),
        "notify_when" -> play.api.libs.json.JsString(obj.notifyWhen.toString)
      )
    }

    implicit def jsonReadsSvcSundialEmrCommand: play.api.libs.json.Reads[EmrCommand] = {
      for {
        emrCluster <- (__ \ "emr_cluster").read[com.hbc.svc.sundial.v2.models.EmrCluster]
        jobName <- (__ \ "job_name").read[String]
        region <- (__ \ "region").read[String]
        `class` <- (__ \ "class").read[String]
        s3JarPath <- (__ \ "s3_jar_path").read[String]
        sparkConf <- (__ \ "spark_conf").read[Seq[String]]
        sparkPackages <- (__ \ "spark_packages").readWithDefault[Seq[com.hbc.svc.sundial.v2.models.MavenPackage]](Nil)
        args <- (__ \ "args").read[Seq[String]]
        s3LogDetails <- (__ \ "s3_log_details").readNullable[com.hbc.svc.sundial.v2.models.S3LogDetails]
        loadData <- (__ \ "load_data").readNullable[Seq[com.hbc.svc.sundial.v2.models.S3Cp]]
        saveResults <- (__ \ "save_results").readNullable[Seq[com.hbc.svc.sundial.v2.models.S3Cp]]
      } yield EmrCommand(emrCluster, jobName, region, `class`, s3JarPath, sparkConf, sparkPackages, args, s3LogDetails, loadData, saveResults)
    }

    def jsObjectEmrCommand(obj: com.hbc.svc.sundial.v2.models.EmrCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "emr_cluster" -> jsObjectEmrCluster(obj.emrCluster),
        "job_name" -> play.api.libs.json.JsString(obj.jobName),
        "region" -> play.api.libs.json.JsString(obj.region),
        "class" -> play.api.libs.json.JsString(obj.`class`),
        "s3_jar_path" -> play.api.libs.json.JsString(obj.s3JarPath),
        "spark_conf" -> play.api.libs.json.Json.toJson(obj.sparkConf),
        "spark_packages" -> play.api.libs.json.Json.toJson(obj.sparkPackages),
        "args" -> play.api.libs.json.Json.toJson(obj.args)
      ) ++ (obj.s3LogDetails match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("s3_log_details" -> jsObjectS3LogDetails(x))
      }) ++
      (obj.loadData match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("load_data" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.saveResults match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("save_results" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsSvcSundialEmrConfiguration: play.api.libs.json.Reads[EmrConfiguration] = {
      for {
        classification <- (__ \ "classification").readNullable[String]
        configurations <- (__ \ "configurations").lazyReadNullable(play.api.libs.json.Reads.of[Seq[com.hbc.svc.sundial.v2.models.EmrConfiguration]])
        properties <- (__ \ "properties").readNullable[Map[String, String]]
      } yield EmrConfiguration(classification, configurations, properties)
    }

    def jsObjectEmrConfiguration(obj: com.hbc.svc.sundial.v2.models.EmrConfiguration): play.api.libs.json.JsObject = {
      (obj.classification match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("classification" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.configurations match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("configurations" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.properties match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("properties" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesSvcSundialEmrConfiguration: play.api.libs.json.Writes[EmrConfiguration] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrConfiguration] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrConfiguration) = {
          jsObjectEmrConfiguration(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialEmrInstanceGroupDetails: play.api.libs.json.Reads[EmrInstanceGroupDetails] = {
      for {
        emrInstanceType <- (__ \ "emr_instance_type").read[String]
        instanceCount <- (__ \ "instance_count").read[Int]
        awsMarket <- (__ \ "aws_market").read[com.hbc.svc.sundial.v2.models.AwsMarket]
        ebsVolumeSize <- (__ \ "ebs_volume_size").readNullable[Int]
      } yield EmrInstanceGroupDetails(emrInstanceType, instanceCount, awsMarket, ebsVolumeSize)
    }

    def jsObjectEmrInstanceGroupDetails(obj: com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "emr_instance_type" -> play.api.libs.json.JsString(obj.emrInstanceType),
        "instance_count" -> play.api.libs.json.JsNumber(obj.instanceCount),
        "aws_market" -> jsObjectAwsMarket(obj.awsMarket)
      ) ++ (obj.ebsVolumeSize match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ebs_volume_size" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesSvcSundialEmrInstanceGroupDetails: play.api.libs.json.Writes[EmrInstanceGroupDetails] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails) = {
          jsObjectEmrInstanceGroupDetails(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialEnvironmentVariable: play.api.libs.json.Reads[EnvironmentVariable] = {
      for {
        variableName <- (__ \ "variable_name").read[String]
        value <- (__ \ "value").read[String]
      } yield EnvironmentVariable(variableName, value)
    }

    def jsObjectEnvironmentVariable(obj: com.hbc.svc.sundial.v2.models.EnvironmentVariable): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "variable_name" -> play.api.libs.json.JsString(obj.variableName),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialEnvironmentVariable: play.api.libs.json.Writes[EnvironmentVariable] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EnvironmentVariable] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EnvironmentVariable) = {
          jsObjectEnvironmentVariable(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialExistingEmrCluster: play.api.libs.json.Reads[ExistingEmrCluster] = {
      (__ \ "cluster_id").read[String].map { x => new ExistingEmrCluster(clusterId = x) }
    }

    def jsObjectExistingEmrCluster(obj: com.hbc.svc.sundial.v2.models.ExistingEmrCluster): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "cluster_id" -> play.api.libs.json.JsString(obj.clusterId)
      )
    }

    implicit def jsonReadsSvcSundialHealthcheck: play.api.libs.json.Reads[Healthcheck] = {
      (__ \ "status").read[String].map { x => new Healthcheck(status = x) }
    }

    def jsObjectHealthcheck(obj: com.hbc.svc.sundial.v2.models.Healthcheck): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesSvcSundialHealthcheck: play.api.libs.json.Writes[Healthcheck] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.Healthcheck] {
        def writes(obj: com.hbc.svc.sundial.v2.models.Healthcheck) = {
          jsObjectHealthcheck(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialLogEntry: play.api.libs.json.Reads[LogEntry] = {
      for {
        logEntryId <- (__ \ "log_entry_id").read[_root_.java.util.UUID]
        when <- (__ \ "when").read[_root_.org.joda.time.DateTime]
        source <- (__ \ "source").read[String]
        message <- (__ \ "message").read[String]
      } yield LogEntry(logEntryId, when, source, message)
    }

    def jsObjectLogEntry(obj: com.hbc.svc.sundial.v2.models.LogEntry): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "log_entry_id" -> play.api.libs.json.JsString(obj.logEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "source" -> play.api.libs.json.JsString(obj.source),
        "message" -> play.api.libs.json.JsString(obj.message)
      )
    }

    implicit def jsonWritesSvcSundialLogEntry: play.api.libs.json.Writes[LogEntry] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.LogEntry] {
        def writes(obj: com.hbc.svc.sundial.v2.models.LogEntry) = {
          jsObjectLogEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialMavenPackage: play.api.libs.json.Reads[MavenPackage] = {
      for {
        groupId <- (__ \ "group_id").read[String]
        artifactId <- (__ \ "artifact_id").read[String]
        version <- (__ \ "version").read[String]
      } yield MavenPackage(groupId, artifactId, version)
    }

    def jsObjectMavenPackage(obj: com.hbc.svc.sundial.v2.models.MavenPackage): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "group_id" -> play.api.libs.json.JsString(obj.groupId),
        "artifact_id" -> play.api.libs.json.JsString(obj.artifactId),
        "version" -> play.api.libs.json.JsString(obj.version)
      )
    }

    implicit def jsonWritesSvcSundialMavenPackage: play.api.libs.json.Writes[MavenPackage] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.MavenPackage] {
        def writes(obj: com.hbc.svc.sundial.v2.models.MavenPackage) = {
          jsObjectMavenPackage(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialMetadataEntry: play.api.libs.json.Reads[MetadataEntry] = {
      for {
        metadataEntryId <- (__ \ "metadata_entry_id").read[_root_.java.util.UUID]
        when <- (__ \ "when").read[_root_.org.joda.time.DateTime]
        key <- (__ \ "key").read[String]
        value <- (__ \ "value").read[String]
      } yield MetadataEntry(metadataEntryId, when, key, value)
    }

    def jsObjectMetadataEntry(obj: com.hbc.svc.sundial.v2.models.MetadataEntry): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "metadata_entry_id" -> play.api.libs.json.JsString(obj.metadataEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialMetadataEntry: play.api.libs.json.Writes[MetadataEntry] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.MetadataEntry] {
        def writes(obj: com.hbc.svc.sundial.v2.models.MetadataEntry) = {
          jsObjectMetadataEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialNewEmrCluster: play.api.libs.json.Reads[NewEmrCluster] = {
      for {
        name <- (__ \ "name").read[String]
        releaseLabel <- (__ \ "release_label").read[com.hbc.svc.sundial.v2.models.EmrReleaseLabel]
        applications <- (__ \ "applications").read[Seq[com.hbc.svc.sundial.v2.models.EmrApplication]]
        s3LogUri <- (__ \ "s3_log_uri").read[String]
        masterInstance <- (__ \ "master_instance").read[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails]
        coreInstance <- (__ \ "core_instance").readNullable[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails]
        taskInstance <- (__ \ "task_instance").readNullable[com.hbc.svc.sundial.v2.models.EmrInstanceGroupDetails]
        ec2Subnet <- (__ \ "ec2_subnet").readNullable[String]
        emrServiceRole <- (__ \ "emr_service_role").read[com.hbc.svc.sundial.v2.models.EmrServiceRole]
        emrJobFlowRole <- (__ \ "emr_job_flow_role").read[com.hbc.svc.sundial.v2.models.EmrJobFlowRole]
        visibleToAllUsers <- (__ \ "visible_to_all_users").read[Boolean]
        configurations <- (__ \ "configurations").readNullable[Seq[com.hbc.svc.sundial.v2.models.EmrConfiguration]]
        securityConfiguration <- (__ \ "security_configuration").readNullable[String]
      } yield NewEmrCluster(name, releaseLabel, applications, s3LogUri, masterInstance, coreInstance, taskInstance, ec2Subnet, emrServiceRole, emrJobFlowRole, visibleToAllUsers, configurations, securityConfiguration)
    }

    def jsObjectNewEmrCluster(obj: com.hbc.svc.sundial.v2.models.NewEmrCluster): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "release_label" -> play.api.libs.json.JsString(obj.releaseLabel.toString),
        "applications" -> play.api.libs.json.Json.toJson(obj.applications),
        "s3_log_uri" -> play.api.libs.json.JsString(obj.s3LogUri),
        "master_instance" -> jsObjectEmrInstanceGroupDetails(obj.masterInstance),
        "emr_service_role" -> jsObjectEmrServiceRole(obj.emrServiceRole),
        "emr_job_flow_role" -> jsObjectEmrJobFlowRole(obj.emrJobFlowRole),
        "visible_to_all_users" -> play.api.libs.json.JsBoolean(obj.visibleToAllUsers)
      ) ++ (obj.coreInstance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("core_instance" -> jsObjectEmrInstanceGroupDetails(x))
      }) ++
      (obj.taskInstance match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("task_instance" -> jsObjectEmrInstanceGroupDetails(x))
      }) ++
      (obj.ec2Subnet match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("ec2_subnet" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.configurations match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("configurations" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.securityConfiguration match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("security_configuration" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonReadsSvcSundialPagerduty: play.api.libs.json.Reads[Pagerduty] = {
      for {
        serviceKey <- (__ \ "service_key").read[String]
        numConsecutiveFailures <- (__ \ "num_consecutive_failures").read[Int]
        apiUrl <- (__ \ "api_url").read[String]
      } yield Pagerduty(serviceKey, numConsecutiveFailures, apiUrl)
    }

    def jsObjectPagerduty(obj: com.hbc.svc.sundial.v2.models.Pagerduty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "service_key" -> play.api.libs.json.JsString(obj.serviceKey),
        "num_consecutive_failures" -> play.api.libs.json.JsNumber(obj.numConsecutiveFailures),
        "api_url" -> play.api.libs.json.JsString(obj.apiUrl)
      )
    }

    implicit def jsonReadsSvcSundialProcess: play.api.libs.json.Reads[Process] = {
      for {
        processId <- (__ \ "process_id").read[_root_.java.util.UUID]
        processDefinitionName <- (__ \ "process_definition_name").read[String]
        startTime <- (__ \ "start_time").read[_root_.org.joda.time.DateTime]
        status <- (__ \ "status").read[com.hbc.svc.sundial.v2.models.ProcessStatus]
        task <- (__ \ "task").read[Seq[com.hbc.svc.sundial.v2.models.Task]]
      } yield Process(processId, processDefinitionName, startTime, status, task)
    }

    def jsObjectProcess(obj: com.hbc.svc.sundial.v2.models.Process): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "task" -> play.api.libs.json.Json.toJson(obj.task)
      )
    }

    implicit def jsonWritesSvcSundialProcess: play.api.libs.json.Writes[Process] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.Process] {
        def writes(obj: com.hbc.svc.sundial.v2.models.Process) = {
          jsObjectProcess(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessDefinition: play.api.libs.json.Reads[ProcessDefinition] = {
      for {
        processDefinitionName <- (__ \ "process_definition_name").read[String]
        paused <- (__ \ "paused").readNullable[Boolean]
        processDescription <- (__ \ "process_description").readNullable[String]
        schedule <- (__ \ "schedule").readNullable[com.hbc.svc.sundial.v2.models.ProcessSchedule]
        taskDefinitions <- (__ \ "task_definitions").read[Seq[com.hbc.svc.sundial.v2.models.TaskDefinition]]
        overlapAction <- (__ \ "overlap_action").read[com.hbc.svc.sundial.v2.models.ProcessOverlapAction]
        notifications <- (__ \ "notifications").readNullable[Seq[com.hbc.svc.sundial.v2.models.Notification]]
      } yield ProcessDefinition(processDefinitionName, paused, processDescription, schedule, taskDefinitions, overlapAction, notifications)
    }

    def jsObjectProcessDefinition(obj: com.hbc.svc.sundial.v2.models.ProcessDefinition): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definitions" -> play.api.libs.json.Json.toJson(obj.taskDefinitions),
        "overlap_action" -> play.api.libs.json.JsString(obj.overlapAction.toString)
      ) ++ (obj.paused match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("paused" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.processDescription match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("process_description" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.schedule match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("schedule" -> jsObjectProcessSchedule(x))
      }) ++
      (obj.notifications match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("notifications" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesSvcSundialProcessDefinition: play.api.libs.json.Writes[ProcessDefinition] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.ProcessDefinition] {
        def writes(obj: com.hbc.svc.sundial.v2.models.ProcessDefinition) = {
          jsObjectProcessDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialS3Cp: play.api.libs.json.Reads[S3Cp] = {
      for {
        source <- (__ \ "source").read[String]
        destination <- (__ \ "destination").read[String]
      } yield S3Cp(source, destination)
    }

    def jsObjectS3Cp(obj: com.hbc.svc.sundial.v2.models.S3Cp): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "source" -> play.api.libs.json.JsString(obj.source),
        "destination" -> play.api.libs.json.JsString(obj.destination)
      )
    }

    implicit def jsonWritesSvcSundialS3Cp: play.api.libs.json.Writes[S3Cp] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.S3Cp] {
        def writes(obj: com.hbc.svc.sundial.v2.models.S3Cp) = {
          jsObjectS3Cp(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialS3LogDetails: play.api.libs.json.Reads[S3LogDetails] = {
      for {
        logGroupName <- (__ \ "log_group_name").read[String]
        logStreamName <- (__ \ "log_stream_name").read[String]
      } yield S3LogDetails(logGroupName, logStreamName)
    }

    def jsObjectS3LogDetails(obj: com.hbc.svc.sundial.v2.models.S3LogDetails): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "log_group_name" -> play.api.libs.json.JsString(obj.logGroupName),
        "log_stream_name" -> play.api.libs.json.JsString(obj.logStreamName)
      )
    }

    implicit def jsonWritesSvcSundialS3LogDetails: play.api.libs.json.Writes[S3LogDetails] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.S3LogDetails] {
        def writes(obj: com.hbc.svc.sundial.v2.models.S3LogDetails) = {
          jsObjectS3LogDetails(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialShellScriptCommand: play.api.libs.json.Reads[ShellScriptCommand] = {
      for {
        script <- (__ \ "script").read[String]
        environmentVariables <- (__ \ "environment_variables").readNullable[Seq[com.hbc.svc.sundial.v2.models.EnvironmentVariable]]
      } yield ShellScriptCommand(script, environmentVariables)
    }

    def jsObjectShellScriptCommand(obj: com.hbc.svc.sundial.v2.models.ShellScriptCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "script" -> play.api.libs.json.JsString(obj.script)
      ) ++ (obj.environmentVariables match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("environment_variables" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsSvcSundialSpot: play.api.libs.json.Reads[Spot] = {
      (__ \ "bid_price").read[BigDecimal].map { x => new Spot(bidPrice = x) }
    }

    def jsObjectSpot(obj: com.hbc.svc.sundial.v2.models.Spot): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "bid_price" -> play.api.libs.json.JsNumber(obj.bidPrice)
      )
    }

    implicit def jsonReadsSvcSundialTask: play.api.libs.json.Reads[Task] = {
      for {
        taskId <- (__ \ "task_id").read[_root_.java.util.UUID]
        processId <- (__ \ "process_id").read[_root_.java.util.UUID]
        processDefinitionName <- (__ \ "process_definition_name").read[String]
        taskDefinitionName <- (__ \ "task_definition_name").read[String]
        startTime <- (__ \ "start_time").read[_root_.org.joda.time.DateTime]
        endTime <- (__ \ "end_time").readNullable[_root_.org.joda.time.DateTime]
        previousAttemptCount <- (__ \ "previous_attempt_count").read[Int]
        logEntries <- (__ \ "log_entries").read[Seq[com.hbc.svc.sundial.v2.models.LogEntry]]
        metadataEntries <- (__ \ "metadata_entries").read[Seq[com.hbc.svc.sundial.v2.models.MetadataEntry]]
        executionState <- (__ \ "execution_state").readNullable[Seq[com.hbc.svc.sundial.v2.models.MetadataEntry]]
        status <- (__ \ "status").read[com.hbc.svc.sundial.v2.models.TaskStatus]
      } yield Task(taskId, processId, processDefinitionName, taskDefinitionName, startTime, endTime, previousAttemptCount, logEntries, metadataEntries, executionState, status)
    }

    def jsObjectTask(obj: com.hbc.svc.sundial.v2.models.Task): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_id" -> play.api.libs.json.JsString(obj.taskId.toString),
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "previous_attempt_count" -> play.api.libs.json.JsNumber(obj.previousAttemptCount),
        "log_entries" -> play.api.libs.json.Json.toJson(obj.logEntries),
        "metadata_entries" -> play.api.libs.json.Json.toJson(obj.metadataEntries),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.endTime match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("end_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
      (obj.executionState match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("execution_state" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesSvcSundialTask: play.api.libs.json.Writes[Task] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.Task] {
        def writes(obj: com.hbc.svc.sundial.v2.models.Task) = {
          jsObjectTask(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDefinition: play.api.libs.json.Reads[TaskDefinition] = {
      for {
        taskDefinitionName <- (__ \ "task_definition_name").read[String]
        dependencies <- (__ \ "dependencies").read[Seq[com.hbc.svc.sundial.v2.models.TaskDependency]]
        executable <- (__ \ "executable").read[com.hbc.svc.sundial.v2.models.TaskExecutable]
        maxAttempts <- (__ \ "max_attempts").read[Int]
        maxRuntimeSeconds <- (__ \ "max_runtime_seconds").readNullable[Int]
        backoffBaseSeconds <- (__ \ "backoff_base_seconds").read[Int]
        backoffExponent <- (__ \ "backoff_exponent").read[Double]
        requireExplicitSuccess <- (__ \ "require_explicit_success").read[Boolean]
      } yield TaskDefinition(taskDefinitionName, dependencies, executable, maxAttempts, maxRuntimeSeconds, backoffBaseSeconds, backoffExponent, requireExplicitSuccess)
    }

    def jsObjectTaskDefinition(obj: com.hbc.svc.sundial.v2.models.TaskDefinition): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "dependencies" -> play.api.libs.json.Json.toJson(obj.dependencies),
        "executable" -> jsObjectTaskExecutable(obj.executable),
        "max_attempts" -> play.api.libs.json.JsNumber(obj.maxAttempts),
        "backoff_base_seconds" -> play.api.libs.json.JsNumber(obj.backoffBaseSeconds),
        "backoff_exponent" -> play.api.libs.json.JsNumber(obj.backoffExponent),
        "require_explicit_success" -> play.api.libs.json.JsBoolean(obj.requireExplicitSuccess)
      ) ++ (obj.maxRuntimeSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max_runtime_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesSvcSundialTaskDefinition: play.api.libs.json.Writes[TaskDefinition] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.TaskDefinition] {
        def writes(obj: com.hbc.svc.sundial.v2.models.TaskDefinition) = {
          jsObjectTaskDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDependency: play.api.libs.json.Reads[TaskDependency] = {
      for {
        taskDefinitionName <- (__ \ "task_definition_name").read[String]
        successRequired <- (__ \ "success_required").read[Boolean]
      } yield TaskDependency(taskDefinitionName, successRequired)
    }

    def jsObjectTaskDependency(obj: com.hbc.svc.sundial.v2.models.TaskDependency): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "success_required" -> play.api.libs.json.JsBoolean(obj.successRequired)
      )
    }

    implicit def jsonWritesSvcSundialTaskDependency: play.api.libs.json.Writes[TaskDependency] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.TaskDependency] {
        def writes(obj: com.hbc.svc.sundial.v2.models.TaskDependency) = {
          jsObjectTaskDependency(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialAwsMarket: play.api.libs.json.Reads[AwsMarket] = {
      (
        (__ \ "on_demand").read(jsonReadsSvcSundialOnDemand).asInstanceOf[play.api.libs.json.Reads[AwsMarket]]
        orElse
        (__ \ "spot").read(jsonReadsSvcSundialSpot).asInstanceOf[play.api.libs.json.Reads[AwsMarket]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.AwsMarketUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[AwsMarket]]
      )
    }

    def jsObjectAwsMarket(obj: com.hbc.svc.sundial.v2.models.AwsMarket): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.OnDemand => play.api.libs.json.Json.obj("on_demand" -> play.api.libs.json.JsString(x.toString))
        case x: com.hbc.svc.sundial.v2.models.Spot => play.api.libs.json.Json.obj("spot" -> jsObjectSpot(x))
        case x: com.hbc.svc.sundial.v2.models.AwsMarketUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.AwsMarketUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialAwsMarket: play.api.libs.json.Writes[AwsMarket] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.AwsMarket] {
        def writes(obj: com.hbc.svc.sundial.v2.models.AwsMarket) = {
          jsObjectAwsMarket(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialEmrCluster: play.api.libs.json.Reads[EmrCluster] = {
      (
        (__ \ "new_emr_cluster").read(jsonReadsSvcSundialNewEmrCluster).asInstanceOf[play.api.libs.json.Reads[EmrCluster]]
        orElse
        (__ \ "existing_emr_cluster").read(jsonReadsSvcSundialExistingEmrCluster).asInstanceOf[play.api.libs.json.Reads[EmrCluster]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrClusterUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[EmrCluster]]
      )
    }

    def jsObjectEmrCluster(obj: com.hbc.svc.sundial.v2.models.EmrCluster): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.NewEmrCluster => play.api.libs.json.Json.obj("new_emr_cluster" -> jsObjectNewEmrCluster(x))
        case x: com.hbc.svc.sundial.v2.models.ExistingEmrCluster => play.api.libs.json.Json.obj("existing_emr_cluster" -> jsObjectExistingEmrCluster(x))
        case x: com.hbc.svc.sundial.v2.models.EmrClusterUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.EmrClusterUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialEmrCluster: play.api.libs.json.Writes[EmrCluster] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrCluster] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrCluster) = {
          jsObjectEmrCluster(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialEmrJobFlowRole: play.api.libs.json.Reads[EmrJobFlowRole] = {
      (
        (__ \ "default_emr_job_flow_role").read(jsonReadsSvcSundialDefaultEmrJobFlowRole).asInstanceOf[play.api.libs.json.Reads[EmrJobFlowRole]]
        orElse
        (__ \ "custom_emr_job_flow_role").read(jsonReadsSvcSundialCustomEmrJobFlowRole).asInstanceOf[play.api.libs.json.Reads[EmrJobFlowRole]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrJobFlowRoleUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[EmrJobFlowRole]]
      )
    }

    def jsObjectEmrJobFlowRole(obj: com.hbc.svc.sundial.v2.models.EmrJobFlowRole): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole => play.api.libs.json.Json.obj("default_emr_job_flow_role" -> play.api.libs.json.JsString(x.toString))
        case x: com.hbc.svc.sundial.v2.models.CustomEmrJobFlowRole => play.api.libs.json.Json.obj("custom_emr_job_flow_role" -> jsObjectCustomEmrJobFlowRole(x))
        case x: com.hbc.svc.sundial.v2.models.EmrJobFlowRoleUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.EmrJobFlowRoleUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialEmrJobFlowRole: play.api.libs.json.Writes[EmrJobFlowRole] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrJobFlowRole] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrJobFlowRole) = {
          jsObjectEmrJobFlowRole(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialEmrServiceRole: play.api.libs.json.Reads[EmrServiceRole] = {
      (
        (__ \ "default_emr_service_role").read(jsonReadsSvcSundialDefaultEmrServiceRole).asInstanceOf[play.api.libs.json.Reads[EmrServiceRole]]
        orElse
        (__ \ "custom_emr_service_role").read(jsonReadsSvcSundialCustomEmrServiceRole).asInstanceOf[play.api.libs.json.Reads[EmrServiceRole]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.EmrServiceRoleUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[EmrServiceRole]]
      )
    }

    def jsObjectEmrServiceRole(obj: com.hbc.svc.sundial.v2.models.EmrServiceRole): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole => play.api.libs.json.Json.obj("default_emr_service_role" -> play.api.libs.json.JsString(x.toString))
        case x: com.hbc.svc.sundial.v2.models.CustomEmrServiceRole => play.api.libs.json.Json.obj("custom_emr_service_role" -> jsObjectCustomEmrServiceRole(x))
        case x: com.hbc.svc.sundial.v2.models.EmrServiceRoleUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.EmrServiceRoleUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialEmrServiceRole: play.api.libs.json.Writes[EmrServiceRole] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.EmrServiceRole] {
        def writes(obj: com.hbc.svc.sundial.v2.models.EmrServiceRole) = {
          jsObjectEmrServiceRole(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialNotification: play.api.libs.json.Reads[Notification] = {
      (
        (__ \ "email").read(jsonReadsSvcSundialEmail).asInstanceOf[play.api.libs.json.Reads[Notification]]
        orElse
        (__ \ "pagerduty").read(jsonReadsSvcSundialPagerduty).asInstanceOf[play.api.libs.json.Reads[Notification]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.NotificationUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[Notification]]
      )
    }

    def jsObjectNotification(obj: com.hbc.svc.sundial.v2.models.Notification): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.Email => play.api.libs.json.Json.obj("email" -> jsObjectEmail(x))
        case x: com.hbc.svc.sundial.v2.models.Pagerduty => play.api.libs.json.Json.obj("pagerduty" -> jsObjectPagerduty(x))
        case x: com.hbc.svc.sundial.v2.models.NotificationUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.NotificationUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialNotification: play.api.libs.json.Writes[Notification] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.Notification] {
        def writes(obj: com.hbc.svc.sundial.v2.models.Notification) = {
          jsObjectNotification(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessSchedule: play.api.libs.json.Reads[ProcessSchedule] = {
      (
        (__ \ "cron_schedule").read(jsonReadsSvcSundialCronSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
        orElse
        (__ \ "continuous_schedule").read(jsonReadsSvcSundialContinuousSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.ProcessScheduleUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
      )
    }

    def jsObjectProcessSchedule(obj: com.hbc.svc.sundial.v2.models.ProcessSchedule): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.CronSchedule => play.api.libs.json.Json.obj("cron_schedule" -> jsObjectCronSchedule(x))
        case x: com.hbc.svc.sundial.v2.models.ContinuousSchedule => play.api.libs.json.Json.obj("continuous_schedule" -> jsObjectContinuousSchedule(x))
        case x: com.hbc.svc.sundial.v2.models.ProcessScheduleUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.ProcessScheduleUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialProcessSchedule: play.api.libs.json.Writes[ProcessSchedule] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.ProcessSchedule] {
        def writes(obj: com.hbc.svc.sundial.v2.models.ProcessSchedule) = {
          jsObjectProcessSchedule(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskExecutable: play.api.libs.json.Reads[TaskExecutable] = {
      (
        (__ \ "shell_script_command").read(jsonReadsSvcSundialShellScriptCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        orElse
        (__ \ "batch_image_command").read(jsonReadsSvcSundialBatchImageCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        orElse
        (__ \ "emr_command").read(jsonReadsSvcSundialEmrCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        orElse
        play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.hbc.svc.sundial.v2.models.TaskExecutableUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
      )
    }

    def jsObjectTaskExecutable(obj: com.hbc.svc.sundial.v2.models.TaskExecutable): play.api.libs.json.JsObject = {
      obj match {
        case x: com.hbc.svc.sundial.v2.models.ShellScriptCommand => play.api.libs.json.Json.obj("shell_script_command" -> jsObjectShellScriptCommand(x))
        case x: com.hbc.svc.sundial.v2.models.BatchImageCommand => play.api.libs.json.Json.obj("batch_image_command" -> jsObjectBatchImageCommand(x))
        case x: com.hbc.svc.sundial.v2.models.EmrCommand => play.api.libs.json.Json.obj("emr_command" -> jsObjectEmrCommand(x))
        case x: com.hbc.svc.sundial.v2.models.TaskExecutableUndefinedType => sys.error(s"The type[com.hbc.svc.sundial.v2.models.TaskExecutableUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialTaskExecutable: play.api.libs.json.Writes[TaskExecutable] = {
      new play.api.libs.json.Writes[com.hbc.svc.sundial.v2.models.TaskExecutable] {
        def writes(obj: com.hbc.svc.sundial.v2.models.TaskExecutable) = {
          jsObjectTaskExecutable(obj)
        }
      }
    }
  }
}

package com.hbc.svc.sundial.v2 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import com.hbc.svc.sundial.v2.models._

      val defaultEmrJobFlowRoleConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole = com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole = com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole.DefaultEmrJobFlowRole
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] = com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole.all
      }
      implicit def pathBindableDefaultEmrJobFlowRole(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] = ApibuilderPathBindable(defaultEmrJobFlowRoleConverter)
      implicit def queryStringBindableDefaultEmrJobFlowRole(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.DefaultEmrJobFlowRole] = ApibuilderQueryStringBindable(defaultEmrJobFlowRoleConverter)

      val defaultEmrServiceRoleConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole = com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole = com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole.DefaultEmrServiceRole
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] = com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole.all
      }
      implicit def pathBindableDefaultEmrServiceRole(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] = ApibuilderPathBindable(defaultEmrServiceRoleConverter)
      implicit def queryStringBindableDefaultEmrServiceRole(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.DefaultEmrServiceRole] = ApibuilderQueryStringBindable(defaultEmrServiceRoleConverter)

      val emrApplicationConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.EmrApplication] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.EmrApplication] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.EmrApplication = com.hbc.svc.sundial.v2.models.EmrApplication(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.EmrApplication): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.EmrApplication = com.hbc.svc.sundial.v2.models.EmrApplication.Hadoop
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.EmrApplication] = com.hbc.svc.sundial.v2.models.EmrApplication.all
      }
      implicit def pathBindableEmrApplication(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.EmrApplication] = ApibuilderPathBindable(emrApplicationConverter)
      implicit def queryStringBindableEmrApplication(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.EmrApplication] = ApibuilderQueryStringBindable(emrApplicationConverter)

      val emrReleaseLabelConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.EmrReleaseLabel = com.hbc.svc.sundial.v2.models.EmrReleaseLabel(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.EmrReleaseLabel): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.EmrReleaseLabel = com.hbc.svc.sundial.v2.models.EmrReleaseLabel.Emr5200
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] = com.hbc.svc.sundial.v2.models.EmrReleaseLabel.all
      }
      implicit def pathBindableEmrReleaseLabel(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] = ApibuilderPathBindable(emrReleaseLabelConverter)
      implicit def queryStringBindableEmrReleaseLabel(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.EmrReleaseLabel] = ApibuilderQueryStringBindable(emrReleaseLabelConverter)

      val notificationOptionsConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.NotificationOptions] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.NotificationOptions] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.NotificationOptions = com.hbc.svc.sundial.v2.models.NotificationOptions(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.NotificationOptions): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.NotificationOptions = com.hbc.svc.sundial.v2.models.NotificationOptions.Always
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.NotificationOptions] = com.hbc.svc.sundial.v2.models.NotificationOptions.all
      }
      implicit def pathBindableNotificationOptions(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.NotificationOptions] = ApibuilderPathBindable(notificationOptionsConverter)
      implicit def queryStringBindableNotificationOptions(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.NotificationOptions] = ApibuilderQueryStringBindable(notificationOptionsConverter)

      val onDemandConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.OnDemand] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.OnDemand] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.OnDemand = com.hbc.svc.sundial.v2.models.OnDemand(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.OnDemand): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.OnDemand = com.hbc.svc.sundial.v2.models.OnDemand.OnDemand
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.OnDemand] = com.hbc.svc.sundial.v2.models.OnDemand.all
      }
      implicit def pathBindableOnDemand(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.OnDemand] = ApibuilderPathBindable(onDemandConverter)
      implicit def queryStringBindableOnDemand(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.OnDemand] = ApibuilderQueryStringBindable(onDemandConverter)

      val processOverlapActionConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.ProcessOverlapAction = com.hbc.svc.sundial.v2.models.ProcessOverlapAction(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.ProcessOverlapAction): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.ProcessOverlapAction = com.hbc.svc.sundial.v2.models.ProcessOverlapAction.Wait
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] = com.hbc.svc.sundial.v2.models.ProcessOverlapAction.all
      }
      implicit def pathBindableProcessOverlapAction(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] = ApibuilderPathBindable(processOverlapActionConverter)
      implicit def queryStringBindableProcessOverlapAction(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.ProcessOverlapAction] = ApibuilderQueryStringBindable(processOverlapActionConverter)

      val processStatusConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.ProcessStatus] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.ProcessStatus] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.ProcessStatus = com.hbc.svc.sundial.v2.models.ProcessStatus(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.ProcessStatus): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.ProcessStatus = com.hbc.svc.sundial.v2.models.ProcessStatus.Running
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.ProcessStatus] = com.hbc.svc.sundial.v2.models.ProcessStatus.all
      }
      implicit def pathBindableProcessStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.ProcessStatus] = ApibuilderPathBindable(processStatusConverter)
      implicit def queryStringBindableProcessStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.ProcessStatus] = ApibuilderQueryStringBindable(processStatusConverter)

      val taskStatusConverter: ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.TaskStatus] = new ApibuilderTypeConverter[com.hbc.svc.sundial.v2.models.TaskStatus] {
        override def convert(value: String): com.hbc.svc.sundial.v2.models.TaskStatus = com.hbc.svc.sundial.v2.models.TaskStatus(value)
        override def convert(value: com.hbc.svc.sundial.v2.models.TaskStatus): String = value.toString
        override def example: com.hbc.svc.sundial.v2.models.TaskStatus = com.hbc.svc.sundial.v2.models.TaskStatus.Submitted
        override def validValues: Seq[com.hbc.svc.sundial.v2.models.TaskStatus] = com.hbc.svc.sundial.v2.models.TaskStatus.all
      }
      implicit def pathBindableTaskStatus(implicit stringBinder: QueryStringBindable[String]): PathBindable[com.hbc.svc.sundial.v2.models.TaskStatus] = ApibuilderPathBindable(taskStatusConverter)
      implicit def queryStringBindableTaskStatus(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[com.hbc.svc.sundial.v2.models.TaskStatus] = ApibuilderQueryStringBindable(taskStatusConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      import org.joda.time.{format, DateTime, LocalDate}

      val dateTimeIso8601: ApibuilderTypeConverter[DateTime] = new ApibuilderTypeConverter[DateTime] {
        override def convert(value: String): DateTime = format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: DateTime): String = format.ISODateTimeFormat.dateTime.print(value)
        override def example: DateTime = DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[LocalDate] = new ApibuilderTypeConverter[LocalDate] {
        override def convert(value: String): LocalDate = format.ISODateTimeFormat.yearMonthDay.parseLocalDate(value)
        override def convert(value: LocalDate): String = value.toString
        override def example: LocalDate = LocalDate.now
      }

    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
